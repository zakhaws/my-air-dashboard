#include <Arduino.h>
#include <Wire.h>
#include <SPI.h>
#include <SD.h>
#include <math.h>
#include "esp_task_wdt.h"

#include "DFRobot_MultiGasSensor.h"
#include "DFRobot_AirQualitySensor.h"
#include "DFRobot_SHT3x.h"
#include "Nextion.h"
#include <WiFi.h>
#include <HTTPClient.h>

// ================= FIREBASE SETTINGS =================
const char* ssid = "NAMA_WIFI_ANDA";
const char* password = "PASSWORD_WIFI_ANDA";
// URL Database Firebase (contoh: https://projek-anda.firebaseio.com)
// PENTING: Jangan pakai tanda "/" (slash) di akhir
const char* firebaseHost = "URL_FIREBASE_ANDA"; 
// Path di database, misal: /sensors.json
const char* firebasePath = "/sensors.json"; 

// ================= TIMER UPLOAD =================
unsigned long lastUpload = 0;
const unsigned long UPLOAD_INTERVAL = 5000; // Kirim setiap 5 detik (Firebase cepat)



// ================= RELAY =================
#define RELAY_GREEN  42
#define RELAY_YELLOW 41
#define RELAY_RED    6

// ================= I2C =================
#define SDA_PIN 8
#define SCL_PIN 9

// ================= SD =================
#define SD_CS 10

// ================= NEXTION UART =================
#define NEXTION_RX_PIN 18  // IO18 = RX
#define NEXTION_TX_PIN 17  // IO17 = TX
#define NEXTION_BAUD 9600

// ================= SHT31F =================
DFRobot_SHT3x sht31(&Wire, 0x45);  // Default I2C address 0x44

// ================= GAS ADDRESS =================
#define CO_ADDR   0x74
#define SO2_ADDR  0x75
#define O3_ADDR   0x76
#define NO2_ADDR  0x77

// ================= PM =================
#define PM25_ADDR 0x19

// ================= OBJECT =================
DFRobot_GAS_I2C gasCO(&Wire, CO_ADDR);
DFRobot_GAS_I2C gasSO2(&Wire, SO2_ADDR);
DFRobot_GAS_I2C gasO3(&Wire, O3_ADDR);
DFRobot_GAS_I2C gasNO2(&Wire, NO2_ADDR);

DFRobot_AirQualitySensor pm25(&Wire, PM25_ADDR);



// ================= NEXTION PAGES =================
NexPage page0 = NexPage(0, 0, "page0");
NexPage page1 = NexPage(1, 0, "page1");
NexPage page2 = NexPage(2, 0, "page2");
NexPage page3 = NexPage(3, 0, "page3");

// ================= NEXTION PAGE1 OBJECTS =================
// Picture components (p_*)
NexPicture p_Kualitas = NexPicture(1, 2, "p_Kualitas");
NexPicture p_PM25 = NexPicture(1, 3, "p_PM25");
NexPicture p_PM10 = NexPicture(1, 5, "p_PM10");
NexPicture p_SO2 = NexPicture(1, 6, "p_SO2");
NexPicture p_Suhu = NexPicture(1, 7, "p_Suhu");
NexPicture p_CO = NexPicture(1, 8, "p_CO");
NexPicture p_O3 = NexPicture(1, 9, "p_O3");
NexPicture p_NO2 = NexPicture(1, 10, "p_NO2");
NexPicture p_Kelembapan = NexPicture(1, 11, "p_Kelembapan");

NexPicture p0 = NexPicture(1, 1, "p0"); 
// Tombol Dual State ID 29
NexDSButton bt0 = NexDSButton(1, 29, "bt0");

// Text components (t_*)
NexText t_Kualitas = NexText(1, 12, "t_Kualitas");
NexText t_PM25 = NexText(1, 13, "t_PM25");
NexText t_PM10 = NexText(1, 14, "t_PM10");
NexText t_SO2 = NexText(1, 15, "t_SO2");
NexText t_Suhu = NexText(1, 16, "t_Suhu");
NexText t_CO = NexText(1, 17, "t_CO");
NexText t_O3 = NexText(1, 18, "t_O3");
NexText t_NO2 = NexText(1, 19, "t_NO2");
NexText t_Kelembapan = NexText(1, 20, "t_Kelembapan");

// Value text components (t_Val_*)
NexText t_Val_PM25 = NexText(1, 21, "t_Val_PM25");
NexText t_Val_PM10 = NexText(1, 22, "t_Val_PM10");
NexText t_Val_SO2 = NexText(1, 23, "t_Val_SO2");
NexText t_Val_Suhu = NexText(1, 24, "t_Val_Suhu");
NexText t_Val_CO = NexText(1, 25, "t_Val_CO");
NexText t_Val_O3 = NexText(1, 26, "t_Val_O3");
NexText t_Val_NO2 = NexText(1, 27, "t_Val_NO2");
NexText t_Val_Kelemb = NexText(1, 28, "t_Val_Kelemb");

// ================= NEXTION PAGE2 WAVEFORM OBJECTS =================
NexWaveform s_PM25 = NexWaveform(2, 2, "s_PM25");      // PM2.5
NexWaveform s_PM10 = NexWaveform(2, 4, "s_PM10");      // PM10
NexWaveform s_Suhu = NexWaveform(2, 5, "s_Suhu");     // Suhu
NexWaveform s_Kelembapan = NexWaveform(2, 6, "s_Kelembapan");  // Kelembapan

// ================= NEXTION PAGE3 WAVEFORM OBJECTS =================
NexWaveform s_SO2 = NexWaveform(3, 6, "s_SO2");        // SO2
NexWaveform s_CO = NexWaveform(3, 3, "s_CO");         // CO
NexWaveform s_O3 = NexWaveform(3, 5, "s_O3");         // O3
NexWaveform s_NO2 = NexWaveform(3, 4, "s_NO2");       // NO2

// Touch event listener list
NexTouch *nex_listen_list[] = {
    &page0, &page1, &page2, &page3,
    &bt0,
    NULL
};

// ================= NEXTION STATE =================
int currentNextionPage = 0;
bool sht31OK = false;

bool showRawData = false;

// ================= TIMER =================
unsigned long lastRead = 0;
const unsigned long READ_INTERVAL = 1000;  // 1 detik
unsigned long systemStartTime = 0;  // waktu mulai sistem
const unsigned long HOUR_MS = 3600000;  // 1 jam dalam millis
const unsigned long DAY_MS = 86400000;  // 24 jam dalam millis

// ================= PM FILTER =================
#define PM_FILTER_WINDOW 6
uint16_t pm25_buffer[PM_FILTER_WINDOW] = {0};
uint16_t pm10_buffer[PM_FILTER_WINDOW] = {0};
uint8_t pm25_buffer_index = 0;
uint8_t pm25_buffer_count = 0;  // jumlah data yang sudah terisi
uint8_t pm10_buffer_index = 0;
uint8_t pm10_buffer_count = 0;  // jumlah data yang sudah terisi
uint16_t last_valid_pm25 = 0;
uint16_t last_valid_pm10 = 0;

// ================= WAVEFORM BUFFER =================
// Buffer untuk menyimpan data waveform (200 data terakhir untuk setiap parameter)
#define WAVEFORM_BUFFER_SIZE 200
uint8_t waveform_pm25_buffer[WAVEFORM_BUFFER_SIZE] = {0};
uint8_t waveform_pm10_buffer[WAVEFORM_BUFFER_SIZE] = {0};
uint8_t waveform_so2_buffer[WAVEFORM_BUFFER_SIZE] = {0};
uint8_t waveform_co_buffer[WAVEFORM_BUFFER_SIZE] = {0};
uint8_t waveform_o3_buffer[WAVEFORM_BUFFER_SIZE] = {0};
uint8_t waveform_no2_buffer[WAVEFORM_BUFFER_SIZE] = {0};
uint8_t waveform_suhu_buffer[WAVEFORM_BUFFER_SIZE] = {0};
uint8_t waveform_kelembapan_buffer[WAVEFORM_BUFFER_SIZE] = {0};

uint16_t waveform_buffer_index = 0;  // Index circular buffer
uint16_t waveform_buffer_count = 0;  // Jumlah data yang sudah terisi (max WAVEFORM_BUFFER_SIZE)
bool waveform_page2_initialized = false;  // Flag untuk cek apakah sudah kirim data ke page2
bool waveform_page3_initialized = false;  // Flag untuk cek apakah sudah kirim data ke page3

// ================= STATUS =================
bool pmOK = false;
bool sdOK = false;
bool coOK = false;
bool so2OK = false;
bool o3OK = false;
bool no2OK = false;

// ================= GAS BASELINE OFFSET (untuk kalibrasi) =================
// Nilai baseline offset untuk mengurangi noise/offset sensor
// Set ke 0 jika tidak perlu offset, atau set ke nilai baseline yang terukur saat kondisi bersih
// CARA KALIBRASI: 
// 1. Letakkan sensor di ruangan bersih (udara segar)
// 2. Catat nilai raw yang terbaca (misal SO2 selalu 0.20 ppm)
// 3. Set baseline offset = nilai tersebut (misal SO2_BASELINE_OFFSET = 0.20)
// 4. Setelah dikurangi offset, nilai seharusnya mendekati 0 di ruangan bersih
float CO_BASELINE_OFFSET = 0.0;      // ppm
float SO2_BASELINE_OFFSET = 0.20;    // ppm - disesuaikan berdasarkan output: raw selalu ~0.20
float O3_BASELINE_OFFSET = 0.0;      // ppm
float NO2_BASELINE_OFFSET = 0.30;    // ppm - disesuaikan berdasarkan output: raw selalu ~0.30

// ================= AIR QUALITY ENUM =================
enum AirQuality {
  AQ_GOOD,
  AQ_MODERATE,
  AQ_UNHEALTHY
};

// ⚠️ FIX UTAMA: paksa update relay pertama kali
AirQuality lastAQ = (AirQuality)-1;

// ================= ISPU DATA STORAGE (24 jam) =================
#define MAX_HOURS 24
struct HourlyData {
  float pm25_sum = 0;
  float pm10_sum = 0;
  float co_sum = 0;
  float so2_sum = 0;
  float o3_sum = 0;
  float no2_sum = 0;
  uint16_t count = 0;  // jumlah pembacaan dalam 1 jam
};

HourlyData hourlyData[MAX_HOURS];
uint8_t currentHourIndex = 0;
unsigned long lastHourReset = 0;

// ================= SD LOG =================
void logToSD(const char *line) {
  if (!sdOK) return;
  File f = SD.open("/log.csv", FILE_APPEND);
  if (f) {
    f.println(line);
    f.close();
  }
}

// ================= I2C SCANNER =================
void scanI2C() {
  Serial.println("\n=== I2C SCAN ===");
  uint8_t found = 0;
  
  for (uint8_t address = 1; address < 127; address++) {
    Wire.beginTransmission(address);
    uint8_t error = Wire.endTransmission();
    
    if (error == 0) {
      Serial.printf("I2C device found at address 0x%02X", address);
      
      // Tampilkan nama device jika diketahui
      if (address == CO_ADDR) Serial.print(" [CO]");
      else if (address == SO2_ADDR) Serial.print(" [SO2]");
      else if (address == O3_ADDR) Serial.print(" [O3]");
      else if (address == NO2_ADDR) Serial.print(" [NO2]");
      else if (address == PM25_ADDR) Serial.print(" [PM2.5/PM10]");
      
      Serial.println();
      found++;
    } else if (error == 4) {
      Serial.printf("Unknown error at address 0x%02X\n", address);
    }
  }
  
  if (found == 0) {
    Serial.println("No I2C devices found!");
  } else {
    Serial.printf("Total devices found: %d\n", found);
  }
  Serial.println("================\n");
}

// ================= INIT GAS =================
bool initGas(DFRobot_GAS_I2C &gas, const char* name) {
  if (gas.begin()) {
    gas.changeAcquireMode(gas.PASSIVITY);
    gas.setTempCompensation(gas.OFF);
    delay(100);  // Delay setelah inisialisasi
    Serial.print(name);
    Serial.println(" READY");
    
    // Test read untuk memastikan sensor merespons
    float test_read = gas.readGasConcentrationPPM();
    Serial.printf("  %s test read: %.2f ppm\n", name, test_read);
    
    return true;
  } else {
    Serial.print(name);
    Serial.println(" FAILED");
    return false;
  }
}

// ================= PM FILTER FUNCTIONS =================
// Fungsi untuk menghitung median dari array
uint16_t calculateMedian(uint16_t arr[], uint8_t count) {
  if (count == 0) return 0;
  
  // Copy array untuk sorting
  uint16_t sorted[PM_FILTER_WINDOW];
  for (uint8_t i = 0; i < count; i++) {
    sorted[i] = arr[i];
  }
  
  // Simple bubble sort
  for (uint8_t i = 0; i < count - 1; i++) {
    for (uint8_t j = 0; j < count - i - 1; j++) {
      if (sorted[j] > sorted[j + 1]) {
        uint16_t temp = sorted[j];
        sorted[j] = sorted[j + 1];
        sorted[j + 1] = temp;
      }
    }
  }
  
  // Return median
  if (count % 2 == 0) {
    return (sorted[count / 2 - 1] + sorted[count / 2]) / 2;
  } else {
    return sorted[count / 2];
  }
}

// Fungsi untuk filter PM dengan outlier detection
uint16_t filterPM(uint16_t new_value, uint16_t buffer[], uint8_t *buffer_index, 
                   uint8_t *buffer_count, uint16_t *last_valid) {
  // Masukkan nilai baru ke buffer
  buffer[*buffer_index] = new_value;
  *buffer_index = (*buffer_index + 1) % PM_FILTER_WINDOW;
  
  if (*buffer_count < PM_FILTER_WINDOW) {
    (*buffer_count)++;
  }
  
  // Hitung median dari buffer
  uint16_t median = calculateMedian(buffer, *buffer_count);
  
  // Deteksi outlier: jika nilai baru berbeda >50% dari median dan median > 0
  if (median > 0 && *buffer_count >= 3) {
    float diff_percent = fabs((float)new_value - (float)median) / (float)median * 100.0;
    
    // Jika outlier (beda >50% dari median), gunakan nilai sebelumnya atau median
    if (diff_percent > 50.0) {
      // Cek apakah nilai ini hanya muncul sekali (outlier)
      uint8_t count_similar = 0;
      for (uint8_t i = 0; i < *buffer_count; i++) {
        if (new_value > 0) {
          float similar_diff = fabs((float)buffer[i] - (float)new_value) / (float)new_value * 100.0;
          if (similar_diff < 10.0) {  // nilai mirip (dalam 10%)
            count_similar++;
          }
        }
      }
      
      // Jika hanya muncul sekali, abaikan dan gunakan nilai sebelumnya atau median
      if (count_similar <= 1) {
        if (*last_valid > 0) {
          return *last_valid;  // gunakan nilai valid terakhir
        } else {
          return median;  // atau gunakan median
        }
      }
    }
  }
  
  // Jika valid, update last_valid dan return nilai baru
  *last_valid = new_value;
  return new_value;
}

// ================= ISPU FUNCTIONS =================
// Struktur untuk batas ISPU
struct ISPUThreshold {
  uint16_t Ia;  // ISPU batas atas
  uint16_t Ib;  // ISPU batas bawah
  float Xa;     // Konsentrasi batas atas
  float Xb;     // Konsentrasi batas bawah
};

// Fungsi untuk mendapatkan threshold ISPU berdasarkan konsentrasi
ISPUThreshold getISPUThreshold(float concentration, const char* parameter) {
  ISPUThreshold th;
  
  if (strcmp(parameter, "PM2.5") == 0) {
    if (concentration <= 15.5) { th.Ia = 50; th.Ib = 0; th.Xa = 15.5; th.Xb = 0; }
    else if (concentration <= 55.4) { th.Ia = 100; th.Ib = 51; th.Xa = 55.4; th.Xb = 15.5; }
    else if (concentration <= 150.4) { th.Ia = 200; th.Ib = 101; th.Xa = 150.4; th.Xb = 55.4; }
    else if (concentration <= 250.4) { th.Ia = 300; th.Ib = 201; th.Xa = 250.4; th.Xb = 150.4; }
    else { th.Ia = 500; th.Ib = 301; th.Xa = 500; th.Xb = 250.4; }  // Sesuai jurnal: 500
  }
  else if (strcmp(parameter, "PM10") == 0) {
    if (concentration <= 50) { th.Ia = 50; th.Ib = 0; th.Xa = 50; th.Xb = 0; }
    else if (concentration <= 150) { th.Ia = 100; th.Ib = 51; th.Xa = 150; th.Xb = 50; }
    else if (concentration <= 350) { th.Ia = 200; th.Ib = 101; th.Xa = 350; th.Xb = 150; }
    else if (concentration <= 420) { th.Ia = 300; th.Ib = 201; th.Xa = 420; th.Xb = 350; }
    else { th.Ia = 500; th.Ib = 301; th.Xa = 500; th.Xb = 420; }
  }
  else if (strcmp(parameter, "CO") == 0) {
    if (concentration <= 4000) { th.Ia = 50; th.Ib = 0; th.Xa = 4000; th.Xb = 0; }
    else if (concentration <= 8000) { th.Ia = 100; th.Ib = 51; th.Xa = 8000; th.Xb = 4000; }
    else if (concentration <= 15000) { th.Ia = 200; th.Ib = 101; th.Xa = 15000; th.Xb = 8000; }
    else if (concentration <= 30000) { th.Ia = 300; th.Ib = 201; th.Xa = 30000; th.Xb = 15000; }
    else { th.Ia = 500; th.Ib = 301; th.Xa = 45000; th.Xb = 30000; }  // Sesuai jurnal: 45000
  }
  else if (strcmp(parameter, "SO2") == 0) {
    if (concentration <= 52) { th.Ia = 50; th.Ib = 0; th.Xa = 52; th.Xb = 0; }
    else if (concentration <= 180) { th.Ia = 100; th.Ib = 51; th.Xa = 180; th.Xb = 52; }
    else if (concentration <= 400) { th.Ia = 200; th.Ib = 101; th.Xa = 400; th.Xb = 180; }
    else if (concentration <= 800) { th.Ia = 300; th.Ib = 201; th.Xa = 800; th.Xb = 400; }
    else { th.Ia = 500; th.Ib = 301; th.Xa = 1200; th.Xb = 800; }
  }
  else if (strcmp(parameter, "O3") == 0) {
    if (concentration <= 120) { th.Ia = 50; th.Ib = 0; th.Xa = 120; th.Xb = 0; }
    else if (concentration <= 235) { th.Ia = 100; th.Ib = 51; th.Xa = 235; th.Xb = 120; }
    else if (concentration <= 400) { th.Ia = 200; th.Ib = 101; th.Xa = 400; th.Xb = 235; }
    else if (concentration <= 800) { th.Ia = 300; th.Ib = 201; th.Xa = 800; th.Xb = 400; }
    else { th.Ia = 500; th.Ib = 301; th.Xa = 1000; th.Xb = 800; }  // Sesuai jurnal: 1000
  }
  else if (strcmp(parameter, "NO2") == 0) {
    if (concentration <= 80) { th.Ia = 50; th.Ib = 0; th.Xa = 80; th.Xb = 0; }
    else if (concentration <= 200) { th.Ia = 100; th.Ib = 51; th.Xa = 200; th.Xb = 80; }
    else if (concentration <= 1130) { th.Ia = 200; th.Ib = 101; th.Xa = 1130; th.Xb = 200; }
    else if (concentration <= 2260) { th.Ia = 300; th.Ib = 201; th.Xa = 2260; th.Xb = 1130; }
    else { th.Ia = 500; th.Ib = 301; th.Xa = 3000; th.Xb = 2260; }
  }
  else {
    // Default (tidak seharusnya terjadi)
    th.Ia = 50; th.Ib = 0; th.Xa = 0; th.Xb = 0;
  }
  
  return th;
}

// Fungsi untuk menghitung ISPU dari konsentrasi
float calculateISPU(float concentration, const char* parameter) {
  if (concentration < 0) return -1;  // data tidak valid
  
  ISPUThreshold th = getISPUThreshold(concentration, parameter);
  
  // Rumus ISPU: I = ((Ia - Ib) / (Xa - Xb)) × (Xx - Xb) + Ib
  if (th.Xa == th.Xb) return th.Ib;  // avoid division by zero
  
  float ispu = ((th.Ia - th.Ib) / (th.Xa - th.Xb)) * (concentration - th.Xb) + th.Ib;
  return ispu;
}

// Fungsi untuk menghitung rata-rata 24 jam (atau data yang tersedia)
// Sesuai jurnal ISPU: Xx = rata-rata konsentrasi 24 jam (atau data yang tersedia jika < 24 jam)
// Logika:
// - Jika baru nyala < 24 jam: Xx = rata-rata dari data yang tersedia (misal 6 jam -> rata-rata 6 jam)
// - Jika sudah >= 24 jam: Xx = rata-rata 24 jam terakhir (rolling/sliding window)
// - Buffer circular: data lama akan ter-overwrite setelah 24 jam (sesuai standar ISPU)
struct Avg24h {
  float pm25 = 0;
  float pm10 = 0;
  float co = 0;
  float so2 = 0;
  float o3 = 0;
  float no2 = 0;
  uint8_t hours_available = 0;
};

Avg24h calculate24hAverage() {
  Avg24h avg;
  uint16_t total_count = 0;
  
  // Hitung total dari semua jam yang ada data
  // Jika < 24 jam: hanya jam yang sudah terisi yang dihitung
  // Jika >= 24 jam: semua 24 jam terakhir dihitung (buffer circular)
  for (uint8_t i = 0; i < MAX_HOURS; i++) {
    if (hourlyData[i].count > 0) {
      avg.pm25 += hourlyData[i].pm25_sum;
      avg.pm10 += hourlyData[i].pm10_sum;
      avg.co += hourlyData[i].co_sum;
      avg.so2 += hourlyData[i].so2_sum;
      avg.o3 += hourlyData[i].o3_sum;
      avg.no2 += hourlyData[i].no2_sum;
      total_count += hourlyData[i].count;
      avg.hours_available++;
    }
  }
  
  // Hitung rata-rata (Xx untuk perhitungan ISPU)
  // Xx = konsentrasi rata-rata 24 jam (atau data yang tersedia)
  if (total_count > 0) {
    avg.pm25 /= total_count;
    avg.pm10 /= total_count;
    avg.co /= total_count;
    avg.so2 /= total_count;
    avg.o3 /= total_count;
    avg.no2 /= total_count;
  }
  
  return avg;
}

// Fungsi untuk reset data per jam (dipanggil setiap jam)
void resetHourlyData() {
  // Reset data jam saat ini
  hourlyData[currentHourIndex].pm25_sum = 0;
  hourlyData[currentHourIndex].pm10_sum = 0;
  hourlyData[currentHourIndex].co_sum = 0;
  hourlyData[currentHourIndex].so2_sum = 0;
  hourlyData[currentHourIndex].o3_sum = 0;
  hourlyData[currentHourIndex].no2_sum = 0;
  hourlyData[currentHourIndex].count = 0;
  
  // Pindah ke jam berikutnya
  currentHourIndex = (currentHourIndex + 1) % MAX_HOURS;
}

// Fungsi untuk menyimpan data ke hourly buffer
void storeHourlyData(uint16_t pm25, uint16_t pm10, float co, float so2, float o3, float no2) {
  if (pm25 >= 0) hourlyData[currentHourIndex].pm25_sum += pm25;
  if (pm10 >= 0) hourlyData[currentHourIndex].pm10_sum += pm10;
  if (co >= 0) hourlyData[currentHourIndex].co_sum += co;
  if (so2 >= 0) hourlyData[currentHourIndex].so2_sum += so2;
  if (o3 >= 0) hourlyData[currentHourIndex].o3_sum += o3;
  if (no2 >= 0) hourlyData[currentHourIndex].no2_sum += no2;
  hourlyData[currentHourIndex].count++;
}

// ================= ISPU STATUS FUNCTIONS =================
// Fungsi untuk menentukan status dari nilai ISPU
AirQuality getStatusFromISPU(float ispu) {
  if (ispu < 0) return AQ_GOOD;  // data tidak valid, default baik
  if (ispu <= 50) return AQ_GOOD;
  if (ispu <= 100) return AQ_MODERATE;
  return AQ_UNHEALTHY;
}

// Fungsi untuk mendapatkan status tertinggi (buruk > sedang > baik)
AirQuality getHighestStatus(AirQuality status1, AirQuality status2) {
  if (status1 == AQ_UNHEALTHY || status2 == AQ_UNHEALTHY) return AQ_UNHEALTHY;
  if (status1 == AQ_MODERATE || status2 == AQ_MODERATE) return AQ_MODERATE;
  return AQ_GOOD;
}

// Fungsi untuk mendapatkan string status
const char* getStatusString(AirQuality aq) {
  if (aq == AQ_GOOD) return "BAIK";
  if (aq == AQ_MODERATE) return "SEDANG";
  return "BURUK";
}

// ================= NEXTION CALLBACKS =================
void page0PushCallback(void *ptr) {
  currentNextionPage = 0;
  Serial.println("Nextion: Page 0");
}

void page1PushCallback(void *ptr) {
  currentNextionPage = 1;
  Serial.println("Nextion: Page 1");
}

void page2PushCallback(void *ptr) {
  currentNextionPage = 2;
  waveform_page2_initialized = false;  // Reset flag, akan kirim data buffer saat update pertama
  Serial.println("Nextion: Page 2");
}

void page3PushCallback(void *ptr) {
  currentNextionPage = 3;
  waveform_page3_initialized = false;  // Reset flag, akan kirim data buffer saat update pertama
  Serial.println("Nextion: Page 3");
}

// [BARU] Callback saat bt0 ditekan/dilepas
void bt0PopCallback(void *ptr) {
  uint32_t number = 0;
  bt0.getValue(&number); // Ambil status tombol (0 atau 1)
  
  if (number == 1 ) {
    showRawData = true;      // Mode RAW DATA
    
    // Ubah gambar p0 jadi ID 19
    Serial2.print("p0.pic=19");
    Serial2.write(0xff); Serial2.write(0xff); Serial2.write(0xff);
    
  } else {
    showRawData = false;     // Mode ISPU
    
    // Ubah gambar p0 jadi ID 20
    Serial2.print("p0.pic=20");
    Serial2.write(0xff); Serial2.write(0xff); Serial2.write(0xff);
  }
}

// ================= NEXTION HELPER FUNCTIONS =================
// Fast command tanpa menunggu konfirmasi (untuk mempercepat update)
void sendNextionCommandFast(const String& command) {
  Serial2.print(command);
  Serial2.write(0xff);
  Serial2.write(0xff);
  Serial2.write(0xff);
  // Tidak menunggu konfirmasi untuk mempercepat
}

void sendNextionTextFast(const String& object, const String& text) {
  String cmd = object + ".txt=\"" + text + "\"";
  sendNextionCommandFast(cmd);
}

void sendNextionPictureFast(const String& object, uint8_t pic) {
  String cmd = object + ".pic=" + String(pic);
  sendNextionCommandFast(cmd);
}

// Fungsi untuk menambahkan data ke waveform (untuk ISPU)
// Waveform menggunakan channel 0 dan nilai 0-255
// Scale ISPU (0-500) ke range waveform (0-255)
void addWaveformISPU(NexWaveform& waveform, float ispu_value) {
  if (ispu_value < 0) return;  // Skip jika data tidak valid
  
  // Scale ISPU (0-500) ke range waveform (0-255)
  // Formula: (ispu / 500) * 255, tapi clamp ke 255 jika > 500
  uint8_t waveform_value;
  if (ispu_value > 500) {
    waveform_value = 255;
  } else {
    waveform_value = (uint8_t)((ispu_value / 500.0) * 255.0);
  }
  
  waveform.addValue(0, waveform_value);
}

// Fungsi untuk menambahkan data ke waveform (untuk nilai sensor langsung)
// Scale nilai sensor ke range waveform (0-255)
// max_value: nilai maksimum yang diharapkan untuk scaling
void addWaveformSensor(NexWaveform& waveform, float sensor_value, float max_value) {
  if (sensor_value < 0) return;  // Skip jika data tidak valid
  
  // Scale sensor value (0-max_value) ke range waveform (0-255)
  uint8_t waveform_value;
  if (sensor_value > max_value) {
    waveform_value = 255;
  } else {
    waveform_value = (uint8_t)((sensor_value / max_value) * 255.0);
  }
  
  waveform.addValue(0, waveform_value);
}

// Fungsi untuk mengirim semua data buffer ke waveform (dipercepat)
void sendWaveformBuffer(NexWaveform& waveform, uint8_t buffer[], uint16_t count) {
  // Kirim semua data dari buffer ke waveform dengan cepat
  // Menggunakan direct command untuk mempercepat (tanpa delay yang tidak perlu)
  for (uint16_t i = 0; i < count; i++) {
    waveform.addValue(0, buffer[i]);
    // Hapus delay untuk mempercepat, Nextion bisa handle data cepat
    // Delay hanya jika benar-benar diperlukan (misal Nextion lambat)
  }
}

// Fungsi untuk menyimpan data ke buffer waveform
void saveWaveformData(float ispu_pm25, float ispu_pm10, float ispu_so2, float ispu_co, 
                      float ispu_o3, float ispu_no2, float suhu, float kelembapan) {
  // Convert dan simpan ke buffer
  uint8_t val_pm25 = (ispu_pm25 >= 0 && ispu_pm25 <= 500) ? (uint8_t)((ispu_pm25 / 500.0) * 255.0) : 0;
  uint8_t val_pm10 = (ispu_pm10 >= 0 && ispu_pm10 <= 500) ? (uint8_t)((ispu_pm10 / 500.0) * 255.0) : 0;
  uint8_t val_so2 = (ispu_so2 >= 0 && ispu_so2 <= 500) ? (uint8_t)((ispu_so2 / 500.0) * 255.0) : 0;
  uint8_t val_co = (ispu_co >= 0 && ispu_co <= 500) ? (uint8_t)((ispu_co / 500.0) * 255.0) : 0;
  uint8_t val_o3 = (ispu_o3 >= 0 && ispu_o3 <= 500) ? (uint8_t)((ispu_o3 / 500.0) * 255.0) : 0;
  uint8_t val_no2 = (ispu_no2 >= 0 && ispu_no2 <= 500) ? (uint8_t)((ispu_no2 / 500.0) * 255.0) : 0;
  uint8_t val_suhu = (suhu >= 0 && suhu <= 50) ? (uint8_t)((suhu / 50.0) * 255.0) : 0;
  uint8_t val_kelembapan = (kelembapan >= 0 && kelembapan <= 100) ? (uint8_t)((kelembapan / 100.0) * 255.0) : 0;
  
  // Simpan ke buffer circular (overwrite data lama setelah penuh)
  // Buffer menggunakan circular buffer: setelah index 199, kembali ke index 0 (tidak shifting)
  waveform_pm25_buffer[waveform_buffer_index] = val_pm25;
  waveform_pm10_buffer[waveform_buffer_index] = val_pm10;
  waveform_so2_buffer[waveform_buffer_index] = val_so2;
  waveform_co_buffer[waveform_buffer_index] = val_co;
  waveform_o3_buffer[waveform_buffer_index] = val_o3;
  waveform_no2_buffer[waveform_buffer_index] = val_no2;
  waveform_suhu_buffer[waveform_buffer_index] = val_suhu;
  waveform_kelembapan_buffer[waveform_buffer_index] = val_kelembapan;
  
  // Update index circular (balik ke 0 setelah mencapai WAVEFORM_BUFFER_SIZE)
  // Contoh: index 199 -> 200 % 200 = 0 (balik ke awal, overwrite data index 0)
  waveform_buffer_index = (waveform_buffer_index + 1) % WAVEFORM_BUFFER_SIZE;
  
  // Update count (maksimal WAVEFORM_BUFFER_SIZE)
  if (waveform_buffer_count < WAVEFORM_BUFFER_SIZE) {
    waveform_buffer_count++;
  }
  // Setelah penuh (count = 200), data lama akan ter-overwrite secara circular
}

// Fungsi untuk update waveform di page2 (PM2.5, PM10, Suhu, Kelembapan)
void updateNextionWaveformPage2(float ispu_pm25, float ispu_pm10, float suhu, float kelembapan) {
  if (currentNextionPage != 2) return;  // Hanya update jika di page2
  
  // Jika pertama kali masuk page2, kirim semua data buffer dulu
  if (!waveform_page2_initialized && waveform_buffer_count > 0) {
    Serial.println("Nextion: Loading waveform buffer to page2...");
    sendWaveformBuffer(s_PM25, waveform_pm25_buffer, waveform_buffer_count);
    sendWaveformBuffer(s_PM10, waveform_pm10_buffer, waveform_buffer_count);
    sendWaveformBuffer(s_Suhu, waveform_suhu_buffer, waveform_buffer_count);
    sendWaveformBuffer(s_Kelembapan, waveform_kelembapan_buffer, waveform_buffer_count);
    waveform_page2_initialized = true;
    Serial.println("Nextion: Waveform buffer loaded to page2");
  }
  
  // Update waveform dengan nilai terbaru (real-time)
  addWaveformISPU(s_PM25, ispu_pm25);  // PM2.5 ISPU
  addWaveformISPU(s_PM10, ispu_pm10);  // PM10 ISPU
  addWaveformSensor(s_Suhu, suhu, 50.0);  // Suhu: range 0-50°C
  addWaveformSensor(s_Kelembapan, kelembapan, 100.0);  // Kelembapan: range 0-100%
}

// Fungsi untuk update waveform di page3 (SO2, CO, O3, NO2)
void updateNextionWaveformPage3(float ispu_so2, float ispu_co, float ispu_o3, float ispu_no2) {
  if (currentNextionPage != 3) return;  // Hanya update jika di page3
  
  // Jika pertama kali masuk page3, kirim semua data buffer dulu
  if (!waveform_page3_initialized && waveform_buffer_count > 0) {
    Serial.println("Nextion: Loading waveform buffer to page3...");
    sendWaveformBuffer(s_SO2, waveform_so2_buffer, waveform_buffer_count);
    sendWaveformBuffer(s_CO, waveform_co_buffer, waveform_buffer_count);
    sendWaveformBuffer(s_O3, waveform_o3_buffer, waveform_buffer_count);
    sendWaveformBuffer(s_NO2, waveform_no2_buffer, waveform_buffer_count);
    waveform_page3_initialized = true;
    Serial.println("Nextion: Waveform buffer loaded to page3");
  }
  
  // Update waveform dengan nilai terbaru (real-time)
  addWaveformISPU(s_SO2, ispu_so2);   // SO2 ISPU
  addWaveformISPU(s_CO, ispu_co);     // CO ISPU
  addWaveformISPU(s_O3, ispu_o3);     // O3 ISPU
  addWaveformISPU(s_NO2, ispu_no2);   // NO2 ISPU
}

// ================= NEXTION UPDATE DISPLAY =================
void updateNextionDisplay(uint16_t pm25v, uint16_t pm10v, float co, float so2, float o3, float no2,
                          float ispu_pm25, float ispu_pm10, float ispu_co, float ispu_so2, 
                          float ispu_o3, float ispu_no2, AirQuality status_pm25, AirQuality status_pm10,
                          AirQuality status_co, AirQuality status_so2, AirQuality status_o3, 
                          AirQuality status_no2, AirQuality status_akhir, float suhu, float kelembapan) {
  if (currentNextionPage != 1) return;  // Hanya update jika di page1
  
  // Update nilai ISPU (t_Val_*) - format: bulat tanpa desimal, tanpa koma ribuan
  // Menggunakan direct command untuk mempercepat (tanpa menunggu konfirmasi)
  char buf[20];
  
  if (showRawData) {
    // === MODE RAW DATA (bt0 = 1) ===
    // PM dikirim angka mentah (integer)
    sendNextionTextFast("t_Val_PM25", String(pm25v));
    sendNextionTextFast("t_Val_PM10", String(pm10v));
    
    // Gas dikirim angka float 1 desimal (ug/m3)
    if (co >= 0) { snprintf(buf, sizeof(buf), "%.1f", co); sendNextionTextFast("t_Val_CO", buf); }
    else sendNextionTextFast("t_Val_CO", "0");
    
    if (so2 >= 0) { snprintf(buf, sizeof(buf), "%.1f", so2); sendNextionTextFast("t_Val_SO2", buf); }
    else sendNextionTextFast("t_Val_SO2", "0");
    
    if (o3 >= 0) { snprintf(buf, sizeof(buf), "%.1f", o3); sendNextionTextFast("t_Val_O3", buf); }
    else sendNextionTextFast("t_Val_O3", "0");
    
    if (no2 >= 0) { snprintf(buf, sizeof(buf), "%.1f", no2); sendNextionTextFast("t_Val_NO2", buf); }
    else sendNextionTextFast("t_Val_NO2", "0");

  } else {
    // === MODE ISPU (bt0 = 0) ===
    // Dikirim angka ISPU (tanpa koma/desimal)
    if (ispu_pm25 >= 0) { snprintf(buf, sizeof(buf), "%.0f", ispu_pm25); sendNextionTextFast("t_Val_PM25", buf); }
    else sendNextionTextFast("t_Val_PM25", "0");
    
    if (ispu_pm10 >= 0) { snprintf(buf, sizeof(buf), "%.0f", ispu_pm10); sendNextionTextFast("t_Val_PM10", buf); }
    else sendNextionTextFast("t_Val_PM10", "0");
    
    if (ispu_so2 >= 0) { snprintf(buf, sizeof(buf), "%.0f", ispu_so2); sendNextionTextFast("t_Val_SO2", buf); }
    else sendNextionTextFast("t_Val_SO2", "0");
    
    if (ispu_co >= 0) { snprintf(buf, sizeof(buf), "%.0f", ispu_co); sendNextionTextFast("t_Val_CO", buf); }
    else sendNextionTextFast("t_Val_CO", "0");
    
    if (ispu_o3 >= 0) { snprintf(buf, sizeof(buf), "%.0f", ispu_o3); sendNextionTextFast("t_Val_O3", buf); }
    else sendNextionTextFast("t_Val_O3", "0");
    
    if (ispu_no2 >= 0) { snprintf(buf, sizeof(buf), "%.0f", ispu_no2); sendNextionTextFast("t_Val_NO2", buf); }
    else sendNextionTextFast("t_Val_NO2", "0");
  }
  
  // Suhu (bukan ISPU, tetap nilai suhu)
  if (suhu >= 0) {
    snprintf(buf, sizeof(buf), "%.0f", suhu);
    sendNextionTextFast("t_Val_Suhu", buf);
  } else {
    sendNextionTextFast("t_Val_Suhu", "0");
  }
  
  // Kelembapan (bukan ISPU, tetap nilai kelembapan)
  if (kelembapan >= 0) {
    snprintf(buf, sizeof(buf), "%.0f", kelembapan);
    sendNextionTextFast("t_Val_Kelemb", buf);
  } else {
    sendNextionTextFast("t_Val_Kelemb", "0");
  }
  
  // Update status text (t_*) - menggunakan direct command untuk mempercepat
  sendNextionTextFast("t_PM25", getStatusString(status_pm25));
  sendNextionTextFast("t_PM10", getStatusString(status_pm10));
  sendNextionTextFast("t_SO2", getStatusString(status_so2));
  sendNextionTextFast("t_CO", getStatusString(status_co));
  sendNextionTextFast("t_O3", getStatusString(status_o3));
  sendNextionTextFast("t_NO2", getStatusString(status_no2));
  sendNextionTextFast("t_Kualitas", getStatusString(status_akhir));
  
  // Suhu dan kelembapan tidak punya status ISPU, set ke "-"
  sendNextionTextFast("t_Suhu", "-");
  sendNextionTextFast("t_Kelembapan", "-");
  
  // Update status picture (p_*) - pic=14 baik, pic=15 sedang, pic=16 buruk
  uint8_t pic_pm25 = (status_pm25 == AQ_GOOD) ? 14 : (status_pm25 == AQ_MODERATE) ? 15 : 16;
  uint8_t pic_pm10 = (status_pm10 == AQ_GOOD) ? 14 : (status_pm10 == AQ_MODERATE) ? 15 : 16;
  uint8_t pic_so2 = (status_so2 == AQ_GOOD) ? 14 : (status_so2 == AQ_MODERATE) ? 15 : 16;
  uint8_t pic_co = (status_co == AQ_GOOD) ? 14 : (status_co == AQ_MODERATE) ? 15 : 16;
  uint8_t pic_o3 = (status_o3 == AQ_GOOD) ? 14 : (status_o3 == AQ_MODERATE) ? 15 : 16;
  uint8_t pic_no2 = (status_no2 == AQ_GOOD) ? 14 : (status_no2 == AQ_MODERATE) ? 15 : 16;
  
  sendNextionPictureFast("p_PM25", pic_pm25);
  sendNextionPictureFast("p_PM10", pic_pm10);
  sendNextionPictureFast("p_SO2", pic_so2);
  sendNextionPictureFast("p_CO", pic_co);
  sendNextionPictureFast("p_O3", pic_o3);
  sendNextionPictureFast("p_NO2", pic_no2);
  
  // Suhu dan kelembapan tidak punya status, set pic ke 14 (baik)
  sendNextionPictureFast("p_Suhu", 14);
  sendNextionPictureFast("p_Kelembapan", 14);
  
  // Update overall quality (p_Kualitas) - pic=11 baik, pic=12 sedang, pic=13 buruk
  uint8_t pic_kualitas = (status_akhir == AQ_GOOD) ? 11 : (status_akhir == AQ_MODERATE) ? 12 : 13;
  sendNextionPictureFast("p_Kualitas", pic_kualitas);
}

// ================= ISPU (PM2.5 INDONESIA) - DEPRECATED =================
AirQuality getAirQuality(uint16_t pm25) {
  if (pm25 <= 15) return AQ_GOOD;
  if (pm25 <= 55) return AQ_MODERATE;
  return AQ_UNHEALTHY;
}

// ================= RELAY CONTROL =================
void setRelayByAirQuality(AirQuality aq) {
  digitalWrite(RELAY_GREEN, LOW);
  digitalWrite(RELAY_YELLOW, LOW);
  digitalWrite(RELAY_RED, LOW);

  if (aq == AQ_GOOD) {
    digitalWrite(RELAY_GREEN, HIGH);
  } else if (aq == AQ_MODERATE) {
    digitalWrite(RELAY_YELLOW, HIGH);
  } else {
    digitalWrite(RELAY_RED, HIGH);
  }
}

// ================= FIREBASE SEND (REST API) =================
void sendToFirebase(float pm25, float pm10, float co, float so2, float o3, float no2, float temp, float hum,
                    float ipm25, float ipm10, float ico, float iso2, float io3, float ino2, float imax, String s_final) {
  
  if (WiFi.status() == WL_CONNECTED) {
    HTTPClient http;
    
    // Construct JSON Payload manually
    String json = "{";
    json += "\"pm25\":" + String(pm25) + ",";
    json += "\"pm10\":" + String(pm10) + ",";
    json += "\"co\":" + String(co) + ",";
    json += "\"so2\":" + String(so2) + ",";
    json += "\"o3\":" + String(o3) + ",";
    json += "\"no2\":" + String(no2) + ",";
    json += "\"temp\":" + String(temp) + ",";
    json += "\"hum\":" + String(hum) + ",";
    json += "\"ispu_pm25\":" + String(ipm25) + ",";
    json += "\"ispu_pm10\":" + String(ipm10) + ",";
    json += "\"ispu_co\":" + String(ico) + ",";
    json += "\"ispu_so2\":" + String(iso2) + ",";
    json += "\"ispu_o3\":" + String(io3) + ",";
    json += "\"ispu_no2\":" + String(ino2) + ",";
    json += "\"ispu_max\":" + String(imax) + ",";
    json += "\"s_final\":\"" + s_final + "\"";
    json += "}";

    // Use Web API for Firebase (PATCH to update, PUT to replace)
    // Format: [BaseURL]/[Path].json
    String url = String(firebaseHost) + String(firebasePath);
    
    // Begin connection (Secure or Insecure)
    http.begin(url);
    
    // Send PATCH request
    int httpResponseCode = http.PATCH(json);
    
    if (httpResponseCode > 0) {
      Serial.print("Firebase Send OK: ");
      Serial.println(httpResponseCode);
    } else {
      Serial.print("Firebase Send Error: ");
      Serial.println(httpResponseCode);
    }
    http.end();
  } else {
    Serial.println("WiFi Disconnected. Cannot send to Firebase.");
  }
}

// ================= SETUP =================
void setup() {
  Serial.begin(115200);

  pinMode(RELAY_GREEN, OUTPUT);
  pinMode(RELAY_YELLOW, OUTPUT);
  pinMode(RELAY_RED, OUTPUT);

  // pastikan semua relay mati dulu
  digitalWrite(RELAY_GREEN, LOW);
  digitalWrite(RELAY_YELLOW, LOW);
  digitalWrite(RELAY_RED, LOW);

  Wire.begin(SDA_PIN, SCL_PIN);
  Wire.setClock(100000);

  // ===== WATCHDOG =====
  esp_task_wdt_init(60, true);
  esp_task_wdt_add(NULL);

  // ===== GAS =====
  coOK  = initGas(gasCO,  "CO");
  so2OK = initGas(gasSO2, "SO2");
  o3OK  = initGas(gasO3,  "O3");
  no2OK = initGas(gasNO2, "NO2");

  // ===== PM =====
  for (int i = 0; i < 5; i++) {
    if (pm25.begin()) {
      pmOK = true;
      Serial.println("PM2.5 READY");
      break;
    }
    delay(500);
  }
  if (!pmOK) Serial.println("PM2.5 FAILED");

  // ===== SD =====
  if (SD.begin(SD_CS)) {
    sdOK = true;
    Serial.println("SD Card OK");
    logToSD("time_ms,pm25,pm10,co_ugm3,so2_ugm3,o3_ugm3,no2_ugm3,ispu_pm25,ispu_pm10,ispu_co,ispu_so2,ispu_o3,ispu_no2,status_pm25,status_pm10,status_co,status_so2,status_o3,status_no2,ispu_max,ispu_param,status_akhir");
  } else {
    Serial.println("SD Card FAILED");
  }
  
  // ===== SHT31F =====
  if (sht31.begin() == 0) {
    sht31OK = true;
    Serial.println("SHT31F READY");
  } else {
    Serial.println("SHT31F FAILED");
  }
  
  // ===== NEXTION =====
  Serial2.begin(NEXTION_BAUD, SERIAL_8N1, NEXTION_RX_PIN, NEXTION_TX_PIN);
  delay(100);
  nexInit();
  
  // Attach page callbacks
  page0.attachPush(page0PushCallback);
  page1.attachPush(page1PushCallback);
  page2.attachPush(page2PushCallback);
  page3.attachPush(page3PushCallback);

  bt0.attachPop(bt0PopCallback, &bt0);
  
  Serial.println("Nextion initialized");
  
  // ===== INIT TIME =====
  systemStartTime = millis();
  lastHourReset = millis();

  // ===== WIFI CONNECT =====
  Serial.print("Connecting to WiFi");
  WiFi.begin(ssid, password);
  
  // Tunggu koneksi (timeout 10 detik agar tidak hang)
  int tryDelay = 0;
  while (WiFi.status() != WL_CONNECTED && tryDelay < 20) {
    delay(500);
    Serial.print(".");
    tryDelay++;
  }
  
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("");
    Serial.println("WiFi connected");
    Serial.println("IP address: ");
    Serial.println(WiFi.localIP());
  } else {
    Serial.println("");
    Serial.println("WiFi connection failed!");
  }
}

// ================= LOOP =================
void loop() {
  esp_task_wdt_reset();
  
  // ===== NEXTION TOUCH EVENTS =====
  nexLoop(nex_listen_list);
  
  unsigned long now = millis();

  // ===== RESET HOURLY DATA (setiap 1 jam) =====
  if (now - lastHourReset >= HOUR_MS) {
    resetHourlyData();
    lastHourReset = now;
  }

  if (now - lastRead >= READ_INTERVAL) {
    lastRead = now;
    
    // ===== I2C SCAN (setiap loop) =====
    scanI2C();

    uint16_t pm25v = 0, pm10v = 0;
    float co = -1, so2 = -1, o3 = -1, no2 = -1;
    float co_raw = -1, so2_raw = -1, o3_raw = -1, no2_raw = -1;

    // ===== PM =====
    if (pmOK) {
      uint16_t pm25_raw = pm25.gainParticleConcentration_ugm3(
                            PARTICLE_PM2_5_STANDARD);
      uint16_t pm10_raw = pm25.gainParticleConcentration_ugm3(
                            PARTICLE_PM10_STANDARD);

      // Filter dengan median filter + outlier detection
      // Abaikan nilai > 20000 (error ekstrem) sebelum filter
      if (pm25_raw <= 20000) {
        pm25v = filterPM(pm25_raw, pm25_buffer, &pm25_buffer_index, 
                        &pm25_buffer_count, &last_valid_pm25);
      } else {
        // Jika error ekstrem, gunakan nilai valid terakhir
        pm25v = last_valid_pm25;
      }
      
      if (pm10_raw <= 20000) {
        pm10v = filterPM(pm10_raw, pm10_buffer, &pm10_buffer_index, 
                        &pm10_buffer_count, &last_valid_pm10);
      } else {
        // Jika error ekstrem, gunakan nilai valid terakhir
        pm10v = last_valid_pm10;
      }
    }

    // ===== GAS (convert PPM to ug/m3) =====
    // Formula: (ppm * BM * 1000) / 24.45
    // BM SO2 = 64.07 g/mol, CO = 28.010 g/mol, O3 = 47.998 g/mol, NO2 = 46.006 g/mol
    // Note: Baseline offset dikurangi untuk menghilangkan noise/offset sensor
    // Note: Sensor CO kadang perlu delay lebih lama untuk merespons
    if (coOK) {
      // Baca beberapa kali dan ambil nilai terakhir (untuk memastikan sensor merespons)
      float co_read1 = gasCO.readGasConcentrationPPM();
      delay(30);
      float co_read2 = gasCO.readGasConcentrationPPM();
      delay(30);
      co_raw = gasCO.readGasConcentrationPPM();  // Ambil pembacaan terakhir
      
      // Debug: tampilkan semua pembacaan untuk CO
      if (co_read1 != co_read2 || co_read2 != co_raw) {
        Serial.printf("CO reads: %.2f, %.2f, %.2f\n", co_read1, co_read2, co_raw);
      }
      
      if (co_raw >= 0) {
        float co_corrected = co_raw - CO_BASELINE_OFFSET;
        if (co_corrected < 0) co_corrected = 0;  // tidak boleh negatif
        co = (co_corrected * 28.010 * 1000.0) / 24.45;
      }
    }
    if (so2OK) {
      so2_raw = gasSO2.readGasConcentrationPPM();
      if (so2_raw >= 0) {
        float so2_corrected = so2_raw - SO2_BASELINE_OFFSET;
        if (so2_corrected < 0) so2_corrected = 0;  // tidak boleh negatif
        so2 = (so2_corrected * 64.07 * 1000.0) / 24.45;
      }
    }
    if (o3OK) {
      o3_raw = gasO3.readGasConcentrationPPM();
      if (o3_raw >= 0) {
        float o3_corrected = o3_raw - O3_BASELINE_OFFSET;
        if (o3_corrected < 0) o3_corrected = 0;  // tidak boleh negatif
        o3 = (o3_corrected * 47.998 * 1000.0) / 24.45;
      }
    }
    if (no2OK) {
      no2_raw = gasNO2.readGasConcentrationPPM();
      if (no2_raw >= 0) {
        float no2_corrected = no2_raw - NO2_BASELINE_OFFSET;
        if (no2_corrected < 0) no2_corrected = 0;  // tidak boleh negatif
        no2 = (no2_corrected * 46.006 * 1000.0) / 24.45;
      }
    }

    // ===== SHT31F (Suhu & Kelembapan) =====
    float suhu = -1.0;
    float kelembapan = -1.0;
    if (sht31OK) {
      suhu = sht31.getTemperatureC();
      kelembapan = sht31.getHumidityRH();
    }

    // ===== STORE DATA TO HOURLY BUFFER =====
    storeHourlyData(pm25v, pm10v, co, so2, o3, no2);

    // ===== CALCULATE 24H AVERAGE =====
    Avg24h avg24h = calculate24hAverage();

    // ===== CALCULATE ISPU FOR EACH PARAMETER =====
    float ispu_pm25 = calculateISPU(avg24h.pm25, "PM2.5");
    float ispu_pm10 = calculateISPU(avg24h.pm10, "PM10");
    float ispu_co = calculateISPU(avg24h.co, "CO");
    float ispu_so2 = calculateISPU(avg24h.so2, "SO2");
    float ispu_o3 = calculateISPU(avg24h.o3, "O3");
    float ispu_no2 = calculateISPU(avg24h.no2, "NO2");

    // ===== DETERMINE STATUS FOR EACH PARAMETER =====
    AirQuality status_pm25 = getStatusFromISPU(ispu_pm25);
    AirQuality status_pm10 = getStatusFromISPU(ispu_pm10);
    AirQuality status_co = getStatusFromISPU(ispu_co);
    AirQuality status_so2 = getStatusFromISPU(ispu_so2);
    AirQuality status_o3 = getStatusFromISPU(ispu_o3);
    AirQuality status_no2 = getStatusFromISPU(ispu_no2);

    // ===== FIND MAX ISPU (ISPU RESMI) =====
    float ispu_max = -1;
    const char* ispu_param = "NONE";
    
    if (ispu_pm25 > ispu_max) { ispu_max = ispu_pm25; ispu_param = "PM2.5"; }
    if (ispu_pm10 > ispu_max) { ispu_max = ispu_pm10; ispu_param = "PM10"; }
    if (ispu_co > ispu_max) { ispu_max = ispu_co; ispu_param = "CO"; }
    if (ispu_so2 > ispu_max) { ispu_max = ispu_so2; ispu_param = "SO2"; }
    if (ispu_o3 > ispu_max) { ispu_max = ispu_o3; ispu_param = "O3"; }
    if (ispu_no2 > ispu_max) { ispu_max = ispu_no2; ispu_param = "NO2"; }

    // ===== DETERMINE HIGHEST STATUS (untuk kontrol relay) =====
    AirQuality aq;
    if (ispu_max < 0) {
      // Belum ada data ISPU, gunakan metode lama
      aq = getAirQuality(pm25v);
    } else {
      // Ambil status tertinggi dari semua parameter
      aq = status_pm25;
      aq = getHighestStatus(aq, status_pm10);
      aq = getHighestStatus(aq, status_co);
      aq = getHighestStatus(aq, status_so2);
      aq = getHighestStatus(aq, status_o3);
      aq = getHighestStatus(aq, status_no2);
    }

    // anti flicker + FIX startup
    if (aq != lastAQ) {
      setRelayByAirQuality(aq);
      lastAQ = aq;
    }

    // ===== SERIAL =====
    Serial.printf(
      "PM2.5:%u | PM10:%u | CO:%.2f (raw:%.2f) | SO2:%.2f (raw:%.2f) | O3:%.2f (raw:%.2f) | NO2:%.2f (raw:%.2f)\r\n",
      pm25v, pm10v, co, co_raw, so2, so2_raw, o3, o3_raw, no2, no2_raw
    );
    
    Serial.printf(
      "ISPU: PM2.5=%.1f(%s) | PM10=%.1f(%s) | CO=%.1f(%s) | SO2=%.1f(%s) | O3=%.1f(%s) | NO2=%.1f(%s) [%dh]\r\n",
      ispu_pm25, getStatusString(status_pm25),
      ispu_pm10, getStatusString(status_pm10),
      ispu_co, getStatusString(status_co),
      ispu_so2, getStatusString(status_so2),
      ispu_o3, getStatusString(status_o3),
      ispu_no2, getStatusString(status_no2),
      avg24h.hours_available
    );
    
    Serial.printf(
      "MAX ISPU=%.1f (%s) | STATUS AKHIR: %s -> ",
      ispu_max, ispu_param, getStatusString(aq)
    );

    if (aq == AQ_GOOD) Serial.println("HIJAU");
    else if (aq == AQ_MODERATE) Serial.println("KUNING");
    else Serial.println("MERAH");

    // ===== UPDATE NEXTION DISPLAY (jika di page1) =====
    updateNextionDisplay(pm25v, pm10v, co, so2, o3, no2,
                        ispu_pm25, ispu_pm10, ispu_co, ispu_so2, ispu_o3, ispu_no2,
                        status_pm25, status_pm10, status_co, status_so2, status_o3, status_no2,
                        aq, suhu, kelembapan);
    
    // ===== SAVE WAVEFORM DATA TO BUFFER =====
    // Simpan data ke buffer setiap pembacaan (untuk ditampilkan saat pindah halaman)
    saveWaveformData(ispu_pm25, ispu_pm10, ispu_so2, ispu_co, ispu_o3, ispu_no2, suhu, kelembapan);
    
    // ===== UPDATE NEXTION WAVEFORM PAGE2 (PM2.5, PM10, Suhu, Kelembapan) =====
    updateNextionWaveformPage2(ispu_pm25, ispu_pm10, suhu, kelembapan);
    
    // ===== UPDATE NEXTION WAVEFORM PAGE3 (SO2, CO, O3, NO2) =====
    updateNextionWaveformPage3(ispu_so2, ispu_co, ispu_o3, ispu_no2);

    // ===== SEND TO FIREBASE (Every X seconds) =====
    if (now - lastUpload >= UPLOAD_INTERVAL) {
      sendToFirebase(pm25v, pm10v, co, so2, o3, no2, suhu, kelembapan,
                     ispu_pm25, ispu_pm10, ispu_co, ispu_so2, ispu_o3, ispu_no2, ispu_max, getStatusString(aq));
      lastUpload = now;
    }

    // ===== SD LOG =====
    char buf[256];
    snprintf(buf, sizeof(buf),
      "%lu,%u,%u,%.2f,%.2f,%.2f,%.2f,%.1f,%.1f,%.1f,%.1f,%.1f,%.1f,%d,%d,%d,%d,%d,%d,%.1f,%s,%d",
      now, pm25v, pm10v, co, so2, o3, no2, 
      ispu_pm25, ispu_pm10, ispu_co, ispu_so2, ispu_o3, ispu_no2,
      status_pm25, status_pm10, status_co, status_so2, status_o3, status_no2,
      ispu_max, ispu_param, aq
    );
    logToSD(buf);
  }
}
